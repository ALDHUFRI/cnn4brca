# Written by: Erick Cobos T. (a01184587@itesm.mx)
# Date: April 2016
""" Calculate IOU measure for different thresholds (for cross-validation)

	Probabilities sampled at random from 10^unif(-3,0), thresholds are the logit
	corresponding to this probability.
	
	Example:
		$ python3 val.py
"""

import tensorflow as tf
import model
import csv
import scipy.misc
import numpy as np

checkpoint_dir = "checkpoint/run3"
csv_path = "val/small_val.csv"
data_dir = "val/"
number_of_thresholds = 3

def post(logits, label, threshold):
	"""Creates segmentation assigning everything over the threshold a value of 
	255, anythig equals to background in label as 0 and anythign else 127. 
	
	Using the label may seem like cheating but the background part of the label 
	was generated by thresholding the original image to zero, so it is as if i
	did that here. Just that it is more cumbersome. Not that important either as
	I calculate IOU for massses and not for backgorund or breats tissue."""
	thresholded = np.ones(logits.shape, dtype='uint8') * 127
	thresholded[logits >= threshold] = 255
	thresholded[label == 0] = 0
	return thresholded
	
def IOU(segmentation, label):
	"""Intersection over union"""
	intersection = np.logical_and(segmentation == 255, label == 255)
	union = np.logical_or(segmentation == 255, label == 255)
	iou = np.sum(intersection)/(np.sum(union) + 1e-7)
	return iou
	
def main():
	""" Loads network, reads image and returns IOU."""
	# Read csv file
	with open(csv_path) as f:
		lines = f.read().splitlines()
		
	# Image as placeholder.
	image = tf.placeholder(tf.float32, name='image')
	expanded = tf.expand_dims(image, 2)
	whitened = tf.image.per_image_whitening(expanded)
	
	# Define the model
	prediction = model.model(whitened, drop=False)
	
	# Get a saver
	saver = tf.train.Saver()

	# Launch the graph
	with tf.Session() as sess:
		# Restore variables
		checkpoint_path = tf.train.latest_checkpoint(checkpoint_dir)
		saver.restore(sess, checkpoint_path)
		model.log("Variables restored from:", checkpoint_path)
		
		for i in range(number_of_thresholds):
			# Get random threshold 
			probability = 10 ** (np.random.random()*3 - 3) # 10^unif(-3,0)
			threshold = np.log(probability) - np.log(1 - probability) # prob2logit
			model.log("Threshold", i, ":", threshold,  "(", probability, ")")
			
			# Reset reader and iou_accum
			csv_reader = csv.reader(lines)
			iou_accum = 0
			
			# For every example
			for row in csv_reader:
				# Read paths
				image_path = data_dir + row[0]
				label_path = data_dir + row[1]

				# Read image and label
				im = scipy.misc.imread(image_path)
				label = scipy.misc.imread(label_path)
			
				# Get prediction
				logits = prediction.eval({image: im})
			
				# Post-process prediction
				segmentation = post(logits, label, threshold)
				
				# Calculate iou				
				iou_accum += IOU(segmentation, label)
			
			# Calculate mean iou
			number_of_examples = csv_reader.line_num
			iou = iou_accum/number_of_examples
			
			# Report iou
			model.log("IOU:", iou)
			
	return iou
	
if __name__ == "__main__":
	main()
